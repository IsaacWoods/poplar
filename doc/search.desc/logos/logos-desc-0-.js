searchState.loadedDescShard("logos", 0, "Logos\nEmit a token with a given value <code>T</code>. Use <code>()</code> for unit …\nEmit a token with a given value <code>T</code>. Use <code>()</code> for unit …\nEmit a <code>&lt;Token as Logos&gt;::ERROR</code> token.\nError type returned by the lexer. This can be set using …\nAssociated type <code>Extras</code> for the particular lexer. This can …\nType that can be returned from a callback, either …\nType that can be returned from a callback, either …\n<code>Lexer</code> is the main struct of the crate that allows you to …\nTrait implemented for an enum representing all tokens. You …\nType that can be returned from a callback, informing the …\nSkip current match, analog to <code>Skip</code>.\nSkip current match, analog to <code>Skip</code>.\nSource type this token can be lexed from. This will …\nByte range in the source.\nIterator that pairs tokens with their position in the …\nBumps the end of currently lexed token by <code>n</code> bytes.\nThe upper bound of the range (exclusive).\nExtras associated with the <code>Token</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe heart of Logos. Called by the <code>Lexer</code>. The …\nCreate a new instance of a <code>Lexer</code> that will produce tokens …\nCreate a new instance of a <code>Lexer</code> with the provided <code>Extras</code> …\nTurn this lexer into a lexer for a new token type.\nCreate a new <code>Lexer</code>.\nGet a slice of remaining source, starting at the end of …\nPredefined callback that will inform the <code>Lexer</code> to skip a …\nGet a string slice of the current token.\nThis module contains a bunch of traits necessary for …\nSource from which this Lexer is reading tokens.\nGet the range for the current token in <code>Source</code>.\nWrap the <code>Lexer</code> in an <code>Iterator</code> that produces tuples of …\nThe lower bound of the range (inclusive).\nCreate a new <code>Lexer</code> with the provided <code>Extras</code>.\nA fixed, statically sized chunk of data that can be read …\nSize of the chunk being accessed in bytes.\nA type this <code>Source</code> can be sliced into.\nTrait for types the <code>Lexer</code> can read from.\nFor <code>&amp;str</code> sources attempts to find the closest <code>char</code> …\nCreate a chunk from a raw byte pointer.\nCheck if <code>index</code> is valid for this <code>Source</code>, that is:\nLength of the source\nRead a chunk of bytes into an array. Returns <code>None</code> when …\nRead a chunk of bytes into an array without doing bounds …\nGet a slice of the source at given range. This is …\nGet a slice of the source at given range. This is …")