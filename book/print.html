<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Poplar</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="kernel/index.html"><strong aria-hidden="true">2.</strong> The Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kernel/platforms/index.html"><strong aria-hidden="true">2.1.</strong> Platforms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kernel/platforms/mqpro.html"><strong aria-hidden="true">2.1.1.</strong> MangoPi MQ-Pro</a></li></ol></li><li class="chapter-item expanded "><a href="kernel/seed.html"><strong aria-hidden="true">2.2.</strong> Seed</a></li><li class="chapter-item expanded "><a href="kernel/kernel_objects.html"><strong aria-hidden="true">2.3.</strong> Kernel Objects</a></li><li class="chapter-item expanded "><a href="kernel/debugging.html"><strong aria-hidden="true">2.4.</strong> Debugging the kernel</a></li></ol></li><li class="chapter-item expanded "><a href="syscalls/index.html"><strong aria-hidden="true">3.</strong> System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syscalls/yield.html"><strong aria-hidden="true">3.1.</strong> yield</a></li><li class="chapter-item expanded "><a href="syscalls/early_log.html"><strong aria-hidden="true">3.2.</strong> early_log</a></li><li class="chapter-item expanded "><a href="syscalls/get_framebuffer.html"><strong aria-hidden="true">3.3.</strong> get_framebuffer</a></li><li class="chapter-item expanded "><a href="syscalls/create_memory_object.html"><strong aria-hidden="true">3.4.</strong> create_memory_object</a></li><li class="chapter-item expanded "><a href="syscalls/map_memory_object.html"><strong aria-hidden="true">3.5.</strong> map_memory_object</a></li><li class="chapter-item expanded "><a href="syscalls/create_channel.html"><strong aria-hidden="true">3.6.</strong> create_channel</a></li><li class="chapter-item expanded "><a href="syscalls/send_message.html"><strong aria-hidden="true">3.7.</strong> send_message</a></li><li class="chapter-item expanded "><a href="syscalls/get_message.html"><strong aria-hidden="true">3.8.</strong> get_message</a></li><li class="chapter-item expanded "><a href="syscalls/register_service.html"><strong aria-hidden="true">3.9.</strong> register_service</a></li><li class="chapter-item expanded "><a href="syscalls/subscribe_to_service.html"><strong aria-hidden="true">3.10.</strong> subscribe_to_service</a></li><li class="chapter-item expanded "><a href="syscalls/pci_get_info.html"><strong aria-hidden="true">3.11.</strong> pci_get_info</a></li></ol></li><li class="chapter-item expanded "><a href="userspace/index.html"><strong aria-hidden="true">4.</strong> Userspace</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="userspace/capabilities.html"><strong aria-hidden="true">4.1.</strong> Capabilities</a></li><li class="chapter-item expanded "><a href="userspace/memory_map_x86_64.html"><strong aria-hidden="true">4.2.</strong> Memory map (x86_64)</a></li></ol></li><li class="chapter-item expanded "><a href="message_passing/index.html"><strong aria-hidden="true">5.</strong> Message Passing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="message_passing/wire_format.html"><strong aria-hidden="true">5.1.</strong> Ptah wire format</a></li></ol></li><li class="chapter-item expanded "><a href="journal/index.html"><strong aria-hidden="true">6.</strong> Journal</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="journal/rustc_target.html"><strong aria-hidden="true">6.1.</strong> Building a rustc target for Poplar</a></li><li class="chapter-item expanded "><a href="journal/usb.html"><strong aria-hidden="true">6.2.</strong> USB</a></li><li class="chapter-item expanded "><a href="journal/riscv.html"><strong aria-hidden="true">6.3.</strong> RISC-V</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Poplar</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Poplar Book, which serves as the main source of documentation for <a href="https://github.com/IsaacWoods/poplar">Poplar</a>.
The Book aims to be both a 10,000-meter overview of Poplar for the interested observer, and a definitive reference for the inner workings of the kernel and userspace. </p>
<p>Please note that this book (like the rest of the OS!) is still very early in development and may lag behind the
state of the code. If anything is unclear, please <a href="https://github.com/IsaacWoods/poplar/issues">file an issue</a>!</p>
<h3 id="what-is-poplar"><a class="header" href="#what-is-poplar">What is Poplar?</a></h3>
<p>At heart, Poplar is a microkernel written in the <a href="https://rust-lang.org">Rust programming language</a>.
Poplar becomes an &quot;OS&quot; when it's combined with other packages such as drivers, filesystems and user applications.</p>
<p>Poplar is designed to be a modern microkernel, supporting a minimal system call interface and first-class support for message-passing-based IPC between userspace processes. Versatile message-passing allows
Poplar to move much more out of the kernel than traditionally possible. For example, the kernel has no concept of a filesystem or of files - instead, the VFS and all filesystems are implemented entirely in
userspace, and files are read and written to by passing messages.</p>
<h3 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h3>
<p>While Poplar's design is in theory language-agnostic, the implementation is very tied to Rust. Rust is a systems programming language with a rich type system and a novel ownership model that guarantees
memory and thread safety <strong>in safe code</strong>. This qualification is important, as Poplar uses a lot of <code>unsafe</code> code out of necessity - it's important to understand that the use of Rust does not in any way
mean that Poplar is automatically bug-free.</p>
<p>However, Rust makes you think a lot more about how to make your programs safe, which is exactly the sort of code we want to be writing for a kernel. This focus on safety, as well as good ergonomics features
and performance, makes Rust perfect for OS-level code.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="the-poplar-kernel"><a class="header" href="#the-poplar-kernel">The Poplar Kernel</a></h3>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platforms"><a class="header" href="#platforms">Platforms</a></h1>
<p>A platform is a build target for the kernel. In some cases, there is only one platform for an entire architecture because the hardware is relatively standardized (e.g. x86_64).
Other times, hardware is different enough between platforms that it's easier to treat them as different targets (e.g. a headless ARM server that boots using UEFI, versus a
Raspberry Pi).</p>
<p>All supported platforms are enumerated in the table below - some have their own sections with more details, while others are just described below. The platform you want to
build for is specified in your <code>Poplar.toml</code> configuration file, or with the <code>-p</code>/<code>--platform</code> flag to <code>xtask</code>. Some platforms also have custom <code>xtask</code> commands to, for
example, flash a device with a built image.</p>
<div class="table-wrapper"><table><thead><tr><th>Platform name</th><th>Arch</th><th>Description</th></tr></thead><tbody>
<tr><td><code>x64</code></td><td>x86_64</td><td>Modern x86_64 platform.</td></tr>
<tr><td><code>rv64_virt</code></td><td>RV64</td><td>A virtual RISC-V QEMU platform.</td></tr>
<tr><td><a href="kernel/platforms/./mqpro.html"><code>mq_pro</code></a></td><td>RV64</td><td>The MangoPi MQ-Pro RISC-V platform.</td></tr>
</tbody></table>
</div>
<h3 id="platform-x64"><a class="header" href="#platform-x64">Platform: <code>x64</code></a></h3>
<p>The vast majority of x86_64 hardware is pretty similar, and so is treated as a single platform. It uses the <code>hal_x86_64</code> HAL. We assume that the platform:</p>
<ul>
<li>Boots using UEFI (using <code>seed_uefi</code>)</li>
<li>Supports the APIC</li>
<li>Supports the <code>xsave</code> instruction</li>
</ul>
<h3 id="platform-rv64_virt"><a class="header" href="#platform-rv64_virt">Platform: <code>rv64_virt</code></a></h3>
<p>This is a virtual RISC-V platform emulated by <code>qemu-system-riscv64</code>'s <code>virt</code> machine. It features:</p>
<ul>
<li>A customizable number of emulated RV64 HARTs</li>
<li>Is booted via QEMU's <code>-kernel</code> option and OpenSBI</li>
<li>A Virtio block device with attached GPT 'disk'</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mangopi-mq-pro"><a class="header" href="#mangopi-mq-pro">MangoPi MQ-Pro</a></h1>
<p>The <a href="https://mangopi.org/mangopi_mqpro">MangoPi MQ-Pro</a> is a small RISC-V development board, featuring an Allwinner D1 SoC with a single RV64 core, and either 512MiB or 1GiB
of memory. Most public information about the D1 itself can be found on the <a href="https://linux-sunxi.org/D1">Sunxi wiki</a>.</p>
<p>You're probably going to want to solder a GPIO header to the board and get a USB-UART adaptor as well. The <code>xtask</code> contains a small serial utility for logging the output from
the board, but you can also use an external program such as <code>minicom</code>.
Adding a male-to-female jumper wire to a ground pin is also useful - you can touch it to the <code>RST</code> pad on the back of the board to reset it (allowing you to FEL new code onto
it).</p>
<h3 id="boot-procedure"><a class="header" href="#boot-procedure">Boot procedure</a></h3>
<p>The D1 can be booted from an SD card or flash, or, usefully for development, using Allwinner's FEL protocol, which allows data to be loaded into memory and code executed using
a small USB stack. This procedure is best visualised with a diagram:
<img src="kernel/platforms/../../static/d1_boot_procedure.svg" alt="Diagram of the D1's boot procedure" /></p>
<p>The initial part of this process is done by code loaded from the <code>BROM</code> (Boot ROM) - it contains the FEL stack, as well as enough code to load the first-stage bootloader from
either an SD card or SPI flash. Data loaded by the FEL stack, or from the bootable media, is loaded into SRAM. The DRAM has to be brought up, either by the first-stage
bootloader, or by a FEL payload.</p>
<h3 id="booting-via-fel"><a class="header" href="#booting-via-fel">Booting via FEL</a></h3>
<p>To boot with FEL, the MQ-Pro needs to be plugged into the development machine via the USB-C OTG port (not the host port), and then booted into FEL mode. The easiest way to do
this is to just remove the SD card - as long as the flash hasn't been written to, this should boot into FEL. It should then enumerate as a USB device with ID <code>1f3a:efe8</code> on
the host.</p>
<p>You then need something that can talk the FEL protocol on the host. We're currently using <a href="https://github.com/xboot/xfel"><code>xfel</code></a>, but this may be replaced/augmented with a
more capable solution in the future. <code>xfel</code> should be relatively easy to compile and install on a Linux system, and should install some udev rules that allow it to be used by
normal users. <code>xfel</code> should then automatically detect a connected device in FEL mode.</p>
<p>The first step is to initialize the DRAM - <code>xfel ddr d1</code> does this by uploading and running a small payload with the correct procedures. After this, further code can be loaded
directly into DRAM - we load OpenSBI and Seed.</p>
<p>Then, we load OpenSBI's <code>FW_JUMP</code> firmware at the start of RAM, <code>0x4000_0000</code>. This provides the SBI interface, moves from M-mode to S-mode, and then jumps into Seed, which is
loaded after 512KiB after it at <code>0x4008_0000</code> (this address is supplied to OpenSBI at build-time). We also bundle a device tree for the platform into OpenSBI, which it uses to
bootstrap the platform, and then supplies it onwards.</p>
<p>TODO: we should investigate customising the driver list to maybe get OpenSBI under 256KiB (it's just over).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="seed"><a class="header" href="#seed">Seed</a></h1>
<p>Seed is Poplar's bootloader Â± pre-kernel. What it is required to do varies by platform, but generally it is
responsible for bringing up the system, loading the kernel and initial tasks into memory, and preparing the
environment for executing the kernel.</p>
<h3 id="x86_64"><a class="header" href="#x86_64"><code>x86_64</code></a></h3>
<p>On <code>x86_64</code>, Seed is an UEFI executable that utilises boot services to load the kernel and initial tasks. The Seed
exectuable, the kernel, and other files are all held in the EFI System Partition (ESP) - a FAT filesystem present
in all UEFI-booted systems.</p>
<h3 id="riscv"><a class="header" href="#riscv"><code>riscv</code></a></h3>
<p>On RiscV, Seed is more of a pre-kernel than a traditional bootloader. It is booted into by the system firmware, and
then has its own set of drivers to load the kernel and other files from the correct filesystem, or elsewhere.</p>
<p><strong>The boot mechanism has not yet been fully designed for RiscV, and also will heavily depend on the hardware
target, as booting different platforms is much less standardised than on x86_64.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-objects"><a class="header" href="#kernel-objects">Kernel Objects</a></h1>
<p>Kernel Objects are how Poplar represents resources that can be interacted with from userspace. They are all
allocated a unique ID.</p>
<h3 id="handles"><a class="header" href="#handles">Handles</a></h3>
<p>Handles are used to refer to kernel objects from userspace, and are allocated to a single Task.
A handle of value <code>0</code> acts as a sentinel value that can be used for special meanings. From userspace, handles
must be treated as opaque, 32-bit integers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-the-kernel"><a class="header" href="#debugging-the-kernel">Debugging the kernel</a></h1>
<p>Kernels can be difficult to debug - this page tries to collect useful techniques for debugging kernels in general,
and also any Poplar specific things that might be useful.</p>
<h3 id="poplar-specific-the-breakpoint-exception"><a class="header" href="#poplar-specific-the-breakpoint-exception">Poplar specific: the breakpoint exception</a></h3>
<p>The breakpoint exception is useful for inspecting the contents of registers at specific points, such as in sections
of assembly (where it's inconvenient to call into Rust, or to use a debugger because getting <code>global_asm!</code> to play
nicely with GDB is a pain).</p>
<p>Simply use the <code>int3</code> instruction:</p>
<pre><code>...

mov rsp, [gs:0x10]
int3  // Is my user stack pointer correct?
sysretq
</code></pre>
<h3 id="building-ovmf"><a class="header" href="#building-ovmf">Building OVMF</a></h3>
<p>Building a debug build of OVMF isn't too hard (from the base of the <code>edk2</code> repo):</p>
<pre><code>OvmfPkg/build.sh -a X64
</code></pre>
<p>By default, debug builds of OVMF will output debugging information on the ISA <code>debugcon</code>, which is actually
probably nicer for our purposes than most builds, which pass <code>DEBUG_ON_SERIAL_PORT</code> during the build. To log the
output to a file, you can pass <code>-debugcon file:ovmf_debug.log -global isa-debugcon.iobase=0x402</code> to QEMU.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-calls"><a class="header" href="#system-calls">System calls</a></h1>
<p>Userspace code can interact with the kernel through system calls. Poplar's system call interface is based around
'kernel objects', and so many of the system calls are to create, destroy, or modify the state of various types of
kernel object. Because of Poplar's microkernel design, many traditional system calls (e.g. <code>open</code>) are not present,
their functionality instead being provided by userspace.</p>
<p>Each system call has a unique number that is used to identify it. A system call can then take up to five
parameters, each a maximum in size of the system's register width. It can return a single value, also the size of
a register.</p>
<h3 id="overview-of-system-calls"><a class="header" href="#overview-of-system-calls">Overview of system calls</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Number</th><th>System call</th><th>Description</th></tr></thead><tbody>
<tr><td><code>0</code></td><td><code>yield</code></td><td>Yield to the kernel.</td></tr>
<tr><td><code>1</code></td><td><code>early_log</code></td><td>Log a message. Designed to be used from early processes.</td></tr>
<tr><td><code>2</code></td><td><code>get_framebuffer</code></td><td>Get the framebuffer that the kernel has created, if it has.</td></tr>
<tr><td><code>3</code></td><td><code>create_memory_object</code></td><td>Create a MemoryObject kernel object.</td></tr>
<tr><td><code>4</code></td><td><code>map_memory_object</code></td><td>Map a MemoryObject into an AddressSpace.</td></tr>
<tr><td><code>5</code></td><td><code>create_channel</code></td><td>Create a channel, returning handles to the two ends.</td></tr>
<tr><td><code>6</code></td><td><code>send_message</code></td><td>Send a message down a channel.</td></tr>
<tr><td><code>7</code></td><td><code>get_message</code></td><td>Receive the next message, if there is one.</td></tr>
<tr><td><code>8</code></td><td><code>wait_for_message</code></td><td>Yield to the kernel until a message arrives on the given channel (WIP)</td></tr>
<tr><td><code>9</code></td><td><code>register_service</code></td><td>Register yourself as a service.</td></tr>
<tr><td><code>10</code></td><td><code>subscribe_to_service</code></td><td>Create a channel to a particular service provider.</td></tr>
<tr><td><code>11</code></td><td><code>pci_get_info</code></td><td>Get information about the PCI devices on the platform.</td></tr>
</tbody></table>
</div>
<h3 id="making-a-system-call-on-x86_64"><a class="header" href="#making-a-system-call-on-x86_64">Making a system call on x86_64</a></h3>
<p>To make a system call on x86_64, populate these registers:</p>
<div class="table-wrapper"><table><thead><tr><th><code>rdi</code></th><th><code>rsi</code></th><th><code>rdx</code></th><th><code>r10</code></th><th><code>r8</code></th><th><code>r9</code></th></tr></thead><tbody>
<tr><td>System call number</td><td><code>a</code></td><td><code>b</code></td><td><code>c</code></td><td><code>d</code></td><td><code>e</code></td></tr>
</tbody></table>
</div>
<p>The only way in which these registers deviate from the x86_64 Sys-V ABI is that <code>c</code> is passed in <code>r10</code> instead of
<code>rcx</code>, because <code>rcx</code> is used by the <code>syscall</code> instruction.  You can then make the system call by executing
<code>syscall</code>. Before the kernel returns to userspace, it will put the result of the system call (if there is one) in
<code>rax</code>. If a system call takes less than five parameters, the unused parameter registers will be preserved across
the system call.</p>
<h3 id="return-values"><a class="header" href="#return-values">Return values</a></h3>
<p>Often, a system call will need to return a status, plus one or more handles. The first handle a system call needs
to return (often the only handle returned) can be returned in the upper bits of the status value:</p>
<ul>
<li>Bits <code>0..32</code> contain the status:
<ul>
<li><code>0</code> means that the system call succeeded, and the rest of the return value is valid</li>
<li><code>&gt;0</code> means that the system call errored. The meaning of the value is system-call specific.</li>
</ul>
</li>
<li>Bits <code>32..64</code> contain the value of the first returned handle, if applicable</li>
</ul>
<p>A return value of <code>0xffffffffffffffff</code> (the maximum value of <code>u64</code>) is reserved for when a system call is made with
a number that does not correspond to a system call. This is defined as a normal error code (as opposed to, for
example, terminating the task that tried to make the system call) to provide a mechanism for tasks to detect kernel
support for a system call (so they can use a fallback method on older kernels, for example).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yield"><a class="header" href="#yield"><code>yield</code></a></h1>
<p>Used by a task that can't do any work at the moment, allowing the kernel to schedule other tasks.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>None.</p>
<h3 id="returns"><a class="header" href="#returns">Returns</a></h3>
<p>Always <code>0</code>.</p>
<h3 id="capabilities-needed"><a class="header" href="#capabilities-needed">Capabilities needed</a></h3>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="early_log"><a class="header" href="#early_log"><code>early_log</code></a></h3>
<p>Used by tasks that are started early in the boot process, before reliable userspace logging support is running.
Output is logged to the same place as kernel logging.</p>
<h3 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h3>
<ul>
<li><code>a</code> - the length of the string to log in bytes. Maximum length is 4096 bytes.</li>
<li><code>b</code> - a usermode pointer to the start of the UTF-8 encoded string.</li>
</ul>
<h3 id="returns-1"><a class="header" href="#returns-1">Returns</a></h3>
<ul>
<li><code>0</code> if the system call succeeded</li>
<li><code>1</code> if the string was too long</li>
<li><code>2</code> if the string was not valid UTF-8</li>
<li><code>3</code> if the task making the syscall doesn't have the <code>EarlyLogging</code> capability</li>
</ul>
<h3 id="capabilities-needed-1"><a class="header" href="#capabilities-needed-1">Capabilities needed</a></h3>
<p>The <code>EarlyLogging</code> capability is needed to make this system call.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_framebuffer"><a class="header" href="#get_framebuffer"><code>get_framebuffer</code></a></h1>
<p>On many architectures, the bootloader or kernel can create a naive framebuffer using a platform-specific method.
This framebuffer can be used to render from userspace, if a better hardware driver is not available on the
platform.</p>
<h3 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h3>
<ul>
<li><code>a</code> should contain a mapped, writable, user-space address, to which information about the framebuffer will
be written.</li>
</ul>
<h3 id="returns-2"><a class="header" href="#returns-2">Returns</a></h3>
<p>This system call returns three things:</p>
<ul>
<li>A status code</li>
<li>A handle to a <code>MemoryObject</code> containing the framebuffer, if successful</li>
<li>Information about the framebuffer, if successful, written into the address in <code>a</code></li>
</ul>
<p>The status codes used are:</p>
<ul>
<li><code>0</code> means that the system call was successful</li>
<li><code>1</code> means that the calling task does not have the correct capability</li>
<li><code>2</code> means that <code>a</code> does not contain a valid address for the kernel to write to</li>
<li><code>3</code> means that the kernel did not create the framebuffer</li>
</ul>
<p>The information written back to the address in <code>a</code> has the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct FramebufferInfo {
    width: u16,
    height: u16,
    stride: u16,
    /// 0 = RGB32
    /// 1 = BGR32
    pixel_format: u8,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="capabilities-needed-2"><a class="header" href="#capabilities-needed-2">Capabilities needed</a></h3>
<p>Tasks need the <code>GetKernelFramebuffer</code> capability to use this system call.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create_memory_object"><a class="header" href="#create_memory_object"><code>create_memory_object</code></a></h1>
<p>Create a MemoryObject kernel object. Userspace can only create &quot;blank&quot; MemoryObjects (that are allocated to free,
conventional physical memory). MemoryObjects that point to special objects (e.g. framebuffer data, PCI
configuration spaces) must be created by the kernel.</p>
<h3 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h3>
<ul>
<li><code>a</code> - the virtual address to map the MemoryObject at</li>
<li><code>b</code> - the size of the MemoryObject's memory area (in bytes)</li>
<li><code>c</code> - flags:
<ul>
<li>Bit <code>0</code>: set if the memory should be writable</li>
<li>Bit <code>1</code>: set if the memory should be executable</li>
</ul>
</li>
<li><code>d</code> - a pointer to which the kernel will write the physical address to which the MemoryObject was allocated. Ignored if null.</li>
</ul>
<h3 id="returns-3"><a class="header" href="#returns-3">Returns</a></h3>
<p>Uses the standard representation to return a <code>Result&lt;Handle, MemoryObjectError&gt;</code> method. Error status
codes are:</p>
<ul>
<li><code>1</code> if the given virtual address is invalid</li>
<li><code>2</code> if the given set of flags are invalid</li>
<li><code>3</code> if memory of the requested size could not be allocated</li>
<li><code>4</code> if the pointer to write the allocated physical address to was not valid</li>
</ul>
<h3 id="capabilities-needed-3"><a class="header" href="#capabilities-needed-3">Capabilities needed</a></h3>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map_memory_object"><a class="header" href="#map_memory_object"><code>map_memory_object</code></a></h1>
<p>Map a MemoryObject into an AddressSpace.</p>
<h3 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h3>
<ul>
<li><code>a</code> - a handle to the MemoryObject.</li>
<li><code>b</code> - a handle to the AddressSpace. The zero handle indicates to map the memory object into the task's AddressSpace.</li>
<li><code>c</code> - the virtual address to map the MemoryObject at, if it does not need to be mapped at a specific address.
Should be null if the MemoryObject supplies the address.</li>
<li><code>d</code> - a pointer to which the kernel will write the virtual address at which the MemoryObject was mapped. Ignored if null.</li>
</ul>
<h3 id="returns-4"><a class="header" href="#returns-4">Returns</a></h3>
<ul>
<li><code>0</code> if the system call succeeded</li>
<li><code>1</code> if either of the passed handles are invalid</li>
<li><code>2</code> if the portion of the AddressSpace that would be mapped is already occupied by another MemoryObject</li>
<li><code>3</code> if the supplied MemoryObject handle does not point to a MemoryHandle</li>
<li><code>4</code> if the supplied AddressSpace handle does not point to an AddressSpace</li>
<li><code>5</code> if the pointer to write the virtual address back to is invalid</li>
<li><code>6</code> if a virtual address to map at was supplied, but the MemoryObject needs to be mapped at a specific address.</li>
<li><code>7</code> if a virtual address was not supplied, but the MemoryObject does not specify the address to map it at.</li>
</ul>
<h3 id="capabilities-needed-4"><a class="header" href="#capabilities-needed-4">Capabilities needed</a></h3>
<p>None (this may change in the future).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create_channel"><a class="header" href="#create_channel"><code>create_channel</code></a></h1>
<p>Create a <code>Channel</code> kernel object. Channels are slightly odd kernel objects in that they must be referred to in
userspace by two handles, one for each &quot;end&quot; of the channel. This system call therefore returns two handles, one of
which is usually transferred to another task.</p>
<h3 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h3>
<ul>
<li><code>a</code> - the virtual address to write the second handle into (only one can be returned in the status)</li>
</ul>
<h3 id="returns-5"><a class="header" href="#returns-5">Returns</a></h3>
<p>Uses the standard representation to return a <code>Result&lt;Handle, CreateChannelError&gt;</code> method. Error status
codes are:</p>
<ul>
<li><code>1</code> if the passed virtual address is not valid</li>
</ul>
<p>TODO: if we ditch the ability to return an error (i.e. by making this infallible, or by saying that a null handle
denotes an error but not which one), we could return both handles in the status.</p>
<h3 id="capabilities-needed-5"><a class="header" href="#capabilities-needed-5">Capabilities needed</a></h3>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send_message"><a class="header" href="#send_message"><code>send_message</code></a></h1>
<p>Send a message, consisting of a number of bytes and optionally a number of handles, down a <code>Channel</code>.
All the handles are removed from the sending <code>Task</code> and added to the receiving <code>Task</code>.</p>
<p>A maximum of 4 handles can be transferred by each message. The maximum number of bytes is currently 4096.</p>
<h3 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h3>
<ul>
<li><code>a</code> - the handle to the <code>Channel</code> end that is sending the message. The handle must have the <code>SEND</code> right.</li>
<li><code>b</code> - a pointer to the array of bytes to send</li>
<li><code>c</code> - the number of bytes to send</li>
<li><code>d</code> - a pointer to the array of handle entries to transfer. All handles must have the <code>TRANSFER</code> right. This may be <code>0x0</code> if the message does not transfer any handles.</li>
<li><code>e</code> - the number of handles to send</li>
</ul>
<h3 id="returns-6"><a class="header" href="#returns-6">Returns</a></h3>
<p>A status code:</p>
<ul>
<li><code>0</code> if the system call succeeded and the message was sent</li>
<li><code>1</code> if the <code>Channel</code> handle is invalid</li>
<li><code>2</code> if the <code>Channel</code> handle does not point to a <code>Channel</code></li>
<li><code>3</code> if the <code>Channel</code> handle does not have the correct rights to send messages</li>
<li><code>4</code> if one or more of the handles to transfer is invalid</li>
<li><code>5</code> if any of the handles to transfer do not have the correct rights</li>
<li><code>6</code> if the pointer to the message bytes was not valid</li>
<li><code>7</code> if the message's byte array is too large</li>
<li><code>8</code> if the pointer to the handles array was not valid</li>
<li><code>9</code> if the handles array is too large</li>
<li><code>10</code> if the other end of the <code>Channel</code> has been disconnected</li>
</ul>
<h3 id="capabilities-needed-6"><a class="header" href="#capabilities-needed-6">Capabilities needed</a></h3>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_message"><a class="header" href="#get_message"><code>get_message</code></a></h1>
<p>Receive a message from a <code>Channel</code>, if one is waiting to be received.</p>
<p>A maximum of 4 handles can be transferred by each message. The maximum number of bytes is currently 4096.</p>
<h3 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h3>
<ul>
<li><code>a</code> - the handle to the <code>Channel</code> end that is receiving the message. The handle must have the <code>RECEIVE</code> right.</li>
<li><code>b</code> - a pointer to the array of bytes to put the message into</li>
<li><code>c</code> - the size of the bytes buffer</li>
<li><code>d</code> - a pointer to the array of handle entries to transfer. This may be <code>0x0</code> if the receiver does not expect to receive any handles.</li>
<li><code>e</code> - the size of the handles buffer (in handles)</li>
</ul>
<h3 id="returns-7"><a class="header" href="#returns-7">Returns</a></h3>
<p>Bits <code>0..16</code> are a status code:</p>
<ul>
<li><code>0</code> if the message was received successfully. The rest of the return value is valid.</li>
<li><code>1</code> if the <code>Channel</code> handle is invalid.</li>
<li><code>2</code> if the <code>Channel</code> handle does not point to a <code>Channel</code>.</li>
<li><code>3</code> if there was no message to receive.</li>
<li><code>4</code> if the address of the bytes buffer is invalid.</li>
<li><code>5</code> if the bytes buffer is too small to contain the message.</li>
<li><code>6</code> if the address of the handles buffer is invalid, or if <code>0x0</code> was passed and the message does contain handles.</li>
<li><code>7</code> if the handles buffer is too small to contain the handles transferred with the message.</li>
</ul>
<p>If the status code is <code>0</code> (i.e. a valid message was written into the bytes and handles buffers), the return value
also contains the number of valid entries in both the byte and handle buffers:</p>
<ul>
<li>Bits <code>16..32</code> contain the length of the valid byte buffer (in bytes). If the passed buffer was larger than this, the
remaining bytes have not been written by the kernel.</li>
<li>Bits <code>32..48</code> contain the length of the valid handles buffer (in handles). If the passed buffer was larger than
this, the remaining bytes have not been written by the kernel.</li>
</ul>
<h3 id="capabilities-needed-7"><a class="header" href="#capabilities-needed-7">Capabilities needed</a></h3>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="register_service"><a class="header" href="#register_service"><code>register_service</code></a></h1>
<p>Register yourself as the provider of a service. The name of the service will be <code>{task_name}.{service_name}</code>. This 
returns a channel that is used to alert the provider when another task subscribes to your service with the
<code>subscribe_to_service</code> system call.</p>
<p>See the section on <a href="syscalls/idk">Services</a> for more information about services, how to register a service, and how to
subscribe to a service.</p>
<h3 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h3>
<ul>
<li><code>a</code> - the length of the name string in bytes. Maximum length is 256. Must be greater than <code>0</code>.</li>
<li><code>b</code> - a usermode pointer to the start of the UTF-8 encoded name string.</li>
</ul>
<h3 id="returns-8"><a class="header" href="#returns-8">Returns</a></h3>
<p>Returns the standard representation of a <code>Result&lt;Handle, ServiceError&gt;</code>. Error status codes are:</p>
<ul>
<li><code>1</code> if the task does not have the correct capability</li>
<li><code>2</code> if the usermode pointer to the name is not valid</li>
<li><code>3</code> if the name is too long, or <code>0</code></li>
</ul>
<p>The returned handle is to a <code>Channel</code> that is used to serve channel subscriptions.</p>
<h3 id="capabilities-needed-8"><a class="header" href="#capabilities-needed-8">Capabilities needed</a></h3>
<p>The <code>ServiceProvider</code> capability is needed to make this system call.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscribe_to_service"><a class="header" href="#subscribe_to_service"><code>subscribe_to_service</code></a></h1>
<p>Subscribe to a registered service by name. This will deliver a notification to the task that registered the
service with one end of a newly created channel. The other end of the channel will be returned by this system call,
if successful.</p>
<p>See the section on <a href="syscalls/idk">Services</a> for more information about services, how to register a service, and how to
subscribe to a service.</p>
<h3 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h3>
<ul>
<li><code>a</code> - the length of the name string in bytes. Maximum length is 256. Must be greater than <code>0</code>.</li>
<li><code>b</code> - a usermode pointer to the start of the UTF-8 encoded name string.</li>
</ul>
<h3 id="returns-9"><a class="header" href="#returns-9">Returns</a></h3>
<p>Returns the standard representation of a <code>Result&lt;Handle, ServiceError&gt;</code>. Error status codes are:</p>
<ul>
<li><code>1</code> if the task does not have the correct capability</li>
<li><code>2</code> if the usermode pointer to the name is not valid</li>
<li><code>3</code> if the name is too long, or <code>0</code></li>
<li><code>4</code> if the supplied name does not correspond to a registered channel.</li>
</ul>
<p>The returned handle is to one end of a <code>Channel</code>, the other end of which has been given to the task that supplies
the service.</p>
<h3 id="capabilities-needed-9"><a class="header" href="#capabilities-needed-9">Capabilities needed</a></h3>
<p>The <code>ServiceUser</code> capability is needed to make this system call.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pci_get_info"><a class="header" href="#pci_get_info"><code>pci_get_info</code></a></h1>
<p>Get information about the PCI devices on the platform. This is only meant to be used from the userspace PCI bus
driver.</p>
<p>TODO: detail structure of PCI descriptor</p>
<h3 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h3>
<ul>
<li><code>a</code> - a pointer to the buffer to put the PCI descriptors in</li>
<li><code>b</code> - the size of the buffer (in descriptors)</li>
</ul>
<h3 id="returns-10"><a class="header" href="#returns-10">Returns</a></h3>
<p>Bits <code>0..16</code> contain a status code:</p>
<ul>
<li><code>0</code> if the system call succeeded</li>
<li><code>1</code> if the task does not have the correct capabilities</li>
<li><code>2</code> if the given buffer can't hold all the descriptors</li>
<li><code>3</code> if the address to the descriptor buffer is invalid</li>
<li><code>4</code> if the platform doesn't support PCI</li>
</ul>
<p>If the status code is <code>0</code> (i.e. the system call succeeded), bits <code>16..48</code> contain the number of descriptors written back.
If the status code is <code>2</code> (i.e. the buffer was not large enough), bits <code>16..48</code> contain the number of entries that
need to be written.</p>
<p>If <code>a</code> is <code>0x0</code>, this system call will always fail with status code <code>2</code> and the number of descriptors in bits
<code>16..48</code>. This is to allow userspace to dynamically allocate a buffer of the correct size, if it desires.</p>
<h3 id="capabilities-needed-10"><a class="header" href="#capabilities-needed-10">Capabilities needed</a></h3>
<p>Tasks need the <code>PciBusDriver</code> capability to use this system call.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poplars-userspace"><a class="header" href="#poplars-userspace">Poplar's userspace</a></h1>
<p>Poplar supports running programs in userspace on supporting architectures. This offers increased protection
and separation compared to running code in kernelspace - as a microkernel, Poplar tries to run as much code
in userspace as possible.</p>
<h2 id="building-a-program-for-poplars-userspace"><a class="header" href="#building-a-program-for-poplars-userspace">Building a program for Poplar's userspace</a></h2>
<p>Currently, the only officially supported language for writing userspace programs is Rust.</p>
<h4 id="target"><a class="header" href="#target">Target</a></h4>
<p>Poplar provides custom target files for userspace programs. These are found in the <code>user/{arch}_poplar.toml</code> files.</p>
<h4 id="standard-library"><a class="header" href="#standard-library">Standard library</a></h4>
<p>Poplar provides a Rust crate, called <code>std</code>, which replaces Rust's standard library. We've done this for a few
reasons:</p>
<ul>
<li>We originally had targets and a <code>std</code> port in a fork of <code>rustc</code>. This proved difficult to maintain and required
users to build a custom Rust fork and add it as a <code>rustup</code> toolchain. This is a high barrier of entry for
anyone wanting to try Poplar out.</li>
<li>Poplar's ideal standard library probably won't end up looking very similar to other platform's, as there are
significant ideological differences in how programs should interact with the OS. This is unfortunate from a
porting point of view, but does allow us to design the platform interface from the group up.</li>
</ul>
<p>The name of the crate is slightly unfortunate, but is required, as <code>rustc</code> uses the name of the crate to decide
where to import the prelude from. This significantly increases the ergonomics we can provide, so is worth the
tradeoff.</p>
<p>The <code>std</code> crate does a few important things that are worth understanding to reduce the 'magic' of Poplar's
userspace:</p>
<ul>
<li>It provides a linker script - the linker script for the correct target is shipped as part of the crate, and
then the build script copies it into the Cargo <code>OUT_DIR</code>. It also passes a directive to <code>rustc</code> such that
you can simply pass <code>-Tlink.ld</code> to link with the correct script. This is, for example, done using <code>RUSTFLAGS</code>
by Poplar's <code>xtask</code>, but you can also pass it manually or with another method, depending on your build system.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h1>
<p>Capabilities describe what a task is allowed to do, and are encoded in its image. This allows users to audit the
permissions of the tasks they run at a much higher granularity than user-based permissions, and also allow us to
move parts of the kernel into discrete userspace tasks by creating specialised capabilities to allow access to
sensitive resources (such as the raw framebuffer) to only select tasks.</p>
<h3 id="encoding-capabilities-in-the-elf-image"><a class="header" href="#encoding-capabilities-in-the-elf-image">Encoding capabilities in the ELF image</a></h3>
<p>Capabilities are encoded in an entry of a <code>PT_NOTE</code> segment of the ELF image of a task. This entry will have an
owner (sometimes referred to in documentation as the 'name') of <code>POPLAR</code> and a type of <code>0</code>. The descriptor will be
an encoding of the capabilities as described by the 'Format' section. The descriptor must be padded such that the
next descriptor is 4-byte aligned, and so a value of <code>0x00</code> is reserved to be used as padding.</p>
<p>Initial images (tasks loaded by the bootloader before filesystem drivers are working) are limited to a capabilities
encoding of 32 bytes (given the variable-length encoding, this does not equate to a fixed maximum number of
capabilities).</p>
<h3 id="format"><a class="header" href="#format">Format</a></h3>
<p>The capabilities format is variable-length - simple capabilities can be encoded as a single byte, while more
complex / specific ones may need multiple bytes of prefix, and can also encode fixed-length data.</p>
<h3 id="overview-of-capabilities"><a class="header" href="#overview-of-capabilities">Overview of capabilities</a></h3>
<p>This is an overview of all the capabilities the kernel supports:</p>
<div class="table-wrapper"><table><thead><tr><th>First byte</th><th>Next byte(s)</th><th>Data</th><th>Arch specific?</th><th>Description</th></tr></thead><tbody>
<tr><td><code>0x00</code></td><td>-</td><td>-</td><td>-</td><td>No meaning - used to pad descriptor to required length (see above)</td></tr>
<tr><td><code>0x01</code></td><td></td><td></td><td>No</td><td><code>GetFramebuffer</code></td></tr>
<tr><td><code>0x02</code></td><td></td><td></td><td>No</td><td><code>EarlyLogging</code></td></tr>
<tr><td><code>0x03</code></td><td></td><td></td><td>No</td><td><code>ServiceProvider</code></td></tr>
<tr><td><code>0x04</code></td><td></td><td></td><td>No</td><td><code>ServiceUser</code></td></tr>
<tr><td><code>0x05</code></td><td>-</td><td>-</td><td>No</td><td><code>PciBusDriver</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="userspace-memory-map-x86_64"><a class="header" href="#userspace-memory-map-x86_64">Userspace memory map (x86_64)</a></h1>
<p>x86_64 features an enormous 256TB virtual address space, most of which is available to userspace processes under Poplar. For this reason, things are spread throughout the virtual address space to make it
easy to identify what a virtual address points to.</p>
<h3 id="userspace-stacks"><a class="header" href="#userspace-stacks">Userspace stacks</a></h3>
<p>Within the virtual address space, the userspace stacks are allocated a 4GB range. Each task has a maximum stack size of 2MB, which puts a limit of 2048 tasks per address space.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h1>
<p>Poplar has a kernel object called a <code>Channel</code> for providing first-class message passing support to userspace.
Channels move packets, called &quot;messages&quot;, which contain a stream of bytes, and optionally one or more handles that
are transferred from the sending task to the receiving task.</p>
<h3 id="ptah"><a class="header" href="#ptah">Ptah</a></h3>
<p>Channels can move arbitrary bytes, but Poplar also includes a layer on top of of Channels called Ptah, which
consists of a data model and wire format suitable for encoding data which can be serialized and deserialized from
any sensible language without too much difficulty.</p>
<p>Ptah is heavily inspired by <a href="https://serde.rs">Serde</a>, and the first implementation of Ptah was actually a <a href="https://github.com/IsaacWoods/poplar/tree/04f3eed45a40f196a02374ca053aaee16517dccb/lib/ptah">Serde
data format</a>.
Unfortunately, it made properly handling Poplar handles very difficult - when a handle is sent over a channel, it
needs to be put into a separate array, and the in-line data replaced by an index into that array.  When the message
travels over a task boundary, the kernel examines and replaces each handle in this array with a handle to the same
kernel object in the new task. This effectively means we need to add a new <code>Handle</code> type to our data model, which
is not easily possible with Serde (and would make it incompatible with standard Serde anyway).</p>
<h3 id="the-ptah-data-model"><a class="header" href="#the-ptah-data-model">The Ptah Data Model</a></h3>
<p>The Ptah data model maps pretty well to the Rust type system, and relatively closely to the Serde data model. Key
differences are some stronger guarantees about the encoding of types such as enums (the data model only needs to
fit a single wire format, and so can afford to be less flexible than Serde's), and the lack of a few types -
<code>unit</code>-based types, and the statically-sized version of <code>seq</code> and <code>map</code> - <code>tuple</code> and <code>struct</code>. Ptah is not a
self-describing format (i.e. the types you're trying to deserialize is fully known), so the elements of structs and
tuples can simply be serialized in the order they appear, and then deserialized in order at the other end.</p>
<ul>
<li>Primitive types
<ul>
<li><code>bool</code></li>
<li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li>
<li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code></li>
<li><code>f32</code>, <code>f64</code></li>
<li><code>char</code></li>
</ul>
</li>
<li><code>string</code>
<ul>
<li>Encoded as a <code>seq</code> of <code>u8</code>, but with the additional requirement that it is valid UTF-8</li>
<li>Not null terminated, as <code>seq</code> includes explicit length</li>
</ul>
</li>
<li><code>option</code>
<ul>
<li>Encoded in the same way as an enum, but separately for the benefit of languages without proper enums</li>
<li>Either <code>None</code> or <code>Some({value})</code></li>
</ul>
</li>
<li><code>enum</code>
<ul>
<li>Include a tag, and optionally some data</li>
<li>Represent a Rust <code>enum</code>, or a tagged union in languages without proper enums</li>
<li>The data is encoded separately to the tag, and can be of any other Ptah type:
<ul>
<li>Rust tuple variants (e.g. <code>E::A(u8, u32)</code>) are represented by <code>tuple</code></li>
<li>Rust struct variants (e.g. <code>E::B { foo: u8, bar: u32 }</code>) are represented by <code>struct</code></li>
</ul>
</li>
</ul>
</li>
<li><code>seq</code>
<ul>
<li>A variable-length sequence of values, mapping to many types such as <code>Vec&lt;T&gt;</code>.</li>
</ul>
</li>
<li><code>map</code>
<ul>
<li>A variable-length series of key-value pairings, mapping to collections like <code>BTreeMap&lt;K, V&gt;</code>.</li>
</ul>
</li>
<li><code>handle</code>
<ul>
<li>This is the type that means we need our own data model in the first place</li>
<li>These are encoded out-of-line of the rest of the data, so that the Poplar kernel can introspect into them, if
it needs to</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ptah-wire-format"><a class="header" href="#the-ptah-wire-format">The Ptah Wire Format</a></h1>
<p>The wire format describes how messages can be encoded into a stream of bytes suitable for transmission over a
channel, or over another transport layer such as the network or a serial port.</p>
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<p>Primitives are transmitted as little-endian and packed to their natural alignment. The following primitive types
are recognised:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td><td>A boolean value</td></tr>
<tr><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></td><td>1, 2, 4, 8</td><td>An unsigned integer</td></tr>
<tr><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code></td><td>1, 2, 4, 8</td><td>A signed integer</td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td>4, 8</td><td>Single / double-precision IEEE-754 FP values</td></tr>
<tr><td><code>char</code></td><td>4</td><td>A single UTF-8 Unicode scalar value</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="journal"><a class="header" href="#journal">Journal</a></h1>
<p>This is just a place I put notes that I make during development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-rustc-target-for-poplar"><a class="header" href="#building-a-rustc-target-for-poplar">Building a <code>rustc</code> target for Poplar</a></h1>
<p>We want a target in <code>rustc</code> for building userspace programs for Poplar. It would be especially cool to get it
merged as an upstream Tier-3 target. This documents my progress, mainly as a reference for me to remember how it all
works.</p>
<h3 id="how-do-i-actually-build-and-use-rustc"><a class="header" href="#how-do-i-actually-build-and-use-rustc">How do I actually build and use <code>rustc</code>?</a></h3>
<p>A useful baseline invocation for normal use is:</p>
<pre><code>./x.py build -i library/std
</code></pre>
<p>The easiest way to test the built <code>rustc</code> is to create a <code>rustup</code> toolchain (from the root of the Rust repo):</p>
<pre><code>rustup toolchain link poplar build/{host triple}/stage1     # If you built a stage-1 compiler (default with invocation above)
rustup toolchain link poplar build/{host triple}/stage2     # If you built a stage-2 compiler
</code></pre>
<p>It's easiest to call your toolchain <code>poplar</code>, as this is the name we use in the Makefiles for now.</p>
<p>You can then use this toolchain from Cargo anywhere on the system with:</p>
<pre><code>cargo +poplar build     # Or whatever command you need
</code></pre>
<h3 id="using-a-custom-llvm"><a class="header" href="#using-a-custom-llvm">Using a custom LLVM</a></h3>
<ul>
<li>Fork Rust's <code>llvm-project</code></li>
<li><code>cd src/llvm_project</code></li>
<li><code>git remote add my_fork {url to your custom LLVM's repo}</code></li>
<li><code>git fetch my_fork</code></li>
<li><code>git checkout my_fork/{the correct branch}</code></li>
<li><code>cd ..</code></li>
<li><code>git add llvm-project</code></li>
<li><code>git commit -m &quot;Move to custom LLVM&quot;</code></li>
</ul>
<h3 id="things-to-change-in-configtoml"><a class="header" href="#things-to-change-in-configtoml">Things to change in <code>config.toml</code></a></h3>
<p>This is as of <code>2020-09-29</code> - you need to remember to keep the <code>config.toml</code> up-to-date (as it's not checked in
upstream), and can cause confusing errors when it's out-of-date.</p>
<ul>
<li><code>download-ci-llvm = true</code> under <code>[llvm]</code>. This makes the build much faster, since we don't need a custom LLVM.</li>
<li><code>assertions = true</code> under <code>[llvm]</code></li>
<li><code>incremental = true</code> under <code>[rust]</code></li>
<li><code>lld = true</code> under <code>[rust]</code>. Without this, the toolchain can't find <code>rust-lld</code> when linking.</li>
<li><code>llvm-tools = true</code> under <code>[rust]</code>. This probably isn't needed, I just chucked it in in case <code>rust-lld</code> needs it.</li>
</ul>
<h3 id="adding-the-target"><a class="header" href="#adding-the-target">Adding the target</a></h3>
<p>I used a slightly different layout to most targets (which have a base, which creates a <code>TargetOptions</code>, and then a
target that modifies and uses those options).</p>
<ul>
<li>Poplar targets generally need a custom linker script. I added one at <code>compiler/rustc_target/src/spec/x86_64_poplar.ld</code>.</li>
<li>Make a module for the target (I called mine <code>compiler/rustc_target/src/spec/x86_64_poplar.rs</code>). Copy from a
existing one. Instead of a separate <code>poplar_base.rs</code> to create the <code>TargetOptions</code>, we do it in the target
itself. We <code>include_str!</code> the linker script in here, so it's distributed as part of the <code>rustc</code> binary.</li>
<li>Add the target in the <code>supported_targets!</code> macro in <code>compiler/rustc_target/src/spec/mod.rs</code>.</li>
</ul>
<h3 id="adding-the-target-to-llvm"><a class="header" href="#adding-the-target-to-llvm">Adding the target to LLVM</a></h3>
<p>I don't really know my way around the LLVM code base, so this was fairly cobbled together:</p>
<ul>
<li>In <code>llvm/include/llvm/ADT/Triple.h</code>, add a variant for the OS in the <code>OSType</code> enum. I called it <code>Poplar</code>. Don't
make it the last entry, to avoid having to change the <code>LastOSType</code> variant.</li>
<li>In <code>llvm/lib/Support/Triple.cpp</code>, in the function <code>Triple::getOSTypeName</code>, add the OS. I added <code>case Poplar: return &quot;poplar&quot;;</code>.</li>
<li>In the same file, in the <code>parseOS</code> function, add the OS. I added <code>.StartsWith(&quot;poplar&quot;, Triple::Poplar)</code>.</li>
<li>This file also contains a function, <code>getDefaultFormat</code>, that gives the default format for a platform. The default
is ELF, so no changes were needed for Poplar, but they might be for another OS.</li>
</ul>
<p>TIP: When you make a change in the <code>llvm-project</code> submodule, you will need to commit these changes, and then update
the submodule in the parent repo, or the bootstrap script will checkout the old version (without your changes) and
build an entire compiler without the changes you are trying to test.</p>
<p>NOTE: to avoid people from having to switch to our <code>llvm-project</code> fork, we don't actually use our LLVM target from
<code>rustc</code> (yet). I'm not sure why you need per-OS targets in LLVM, as it doesn't even seem to let us do any of the
things we wanted to (this totally might just be me not knowing how LLVM targets work).</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>We needed to change the entry point to <code>_start</code>, or it silently just doesn't emit any sections in the final
image.</li>
<li>By default, it throws away our <code>.caps</code> sections. We need a way to emit it regardless - this is done by manually
creating the program header and specifying that they should be kept with <code>KEEP</code>. There are two possible solutions
that I can see: make <code>rustc</code> emit a linker script, or try and introduce these ideas into <code>llvm</code>/<code>lld</code> with our
target (I'm not even sure this is possible).</li>
<li>It looks like <code>lld</code> has no OS-specific code at all, and the only place that specifically-kept sections are added
is in the linker script parser. Looks like we might have to actually create a file-based linker script (does
literally noone else need to pass a linker script by command line??).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usb"><a class="header" href="#usb">USB</a></h1>
<p>USB has a <strong>host</strong> that sends requests to <strong>devices</strong> (devices only respond when asked something). Some devices are
<strong>dual role devices (DRD)</strong> (previously called On-The-Go (OTG) devices), and can dynamically negotiate whether
they're the host or the device.</p>
<p>Each device can have one ore more <strong>interfaces</strong>, which each have one or more <strong>endpoints</strong>. Each endpoint has a
hardcoded direction (host-to-device or device-to-host). There are a few types of endpoint (the type is decided
during interface configuration):</p>
<ul>
<li><strong>Control endpoints</strong> are for configuration and control requests</li>
<li><strong>Bulk endpoints</strong> are for bulk transfers</li>
<li><strong>Isochronous endpoints</strong> are for periodic transfers with a reserved bandwidth</li>
<li><strong>Int endpoints</strong> are for transfers triggered by interruptions</li>
</ul>
<p>The interfaces and endpoints a device has are described by descriptors reported by the device during configuration.</p>
<p>Every device has a special endpoint called <code>ep0</code>. It's an in+out control endpoint, and is used to configure the
other endpoints.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="risc-v"><a class="header" href="#risc-v">RISC-V</a></h1>
<h3 id="building-opensbi"><a class="header" href="#building-opensbi">Building OpenSBI</a></h3>
<p>OpenSBI is the reference implementation for the Supervisor Binary Interface (SBI). It's basically how you access
M-mode functionality from your S-mode bootloader or kernel.</p>
<p>Firstly, we need a RISC-V C toolchain. On Arch, I installed the <code>riscv64-unknown-elf-binutils</code> AUR package. I also
tried to install the <code>riscv64-unknown-elf-gcc</code> package, but this wouldn't work, so I built OpenSBI with Clang+LLVM
instead with (from inside <code>lib/opensbi</code>):</p>
<pre><code>make PLATFORM=generic LLVM=1
</code></pre>
<p>This can be tested on QEMU with:</p>
<pre><code>qemu-system-riscv64 -M virt -bios build/platform/generic/firmware/fw_jump.elf
</code></pre>
<p>It also seems like you can build with a platform of <code>qemu/virt</code> - I'm not sure what difference this makes yet
but guessing it's the hardware it assumes it needs to drive? Worth exploring. (Apparently the <code>generic</code> image is
doing dynamic discovery (I'm assuming from the device tree) so that sounds good for now).</p>
<p>So the jump firmware (<code>fw_jump.elf</code>) jumps to a specified address in memory (apparently QEMU can load an ELF which
would be fine initially). Other option would be a payload firmware, which bundles your code into the SBI image
(assuming as a flat binary) and executes it like that.</p>
<p>We should probably make an <code>xtask</code> step to build OpenSBI and move it to the <code>bundled</code> directory, plus decide what
sort of firmware / booting strategy we're going to use. Then the next step would be some Rust code that can print
to the serial port, to prove it's all working.</p>
<h3 id="qemu-virt-memory-map"><a class="header" href="#qemu-virt-memory-map">QEMU <code>virt</code> memory map</a></h3>
<p>Seems everything is memory-mapped, which makes for a nice change coming from x86's nasty port thingy. This is the
<code>virt</code> machine's one (from the QEMU source...):</p>
<div class="table-wrapper"><table><thead><tr><th>Region</th><th>Address</th><th>Size</th></tr></thead><tbody>
<tr><td>Debug</td><td><code>0x0</code></td><td><code>0x100</code></td></tr>
<tr><td>MROM</td><td><code>0x1000</code></td><td><code>0x11000</code></td></tr>
<tr><td>Test</td><td><code>0x100000</code></td><td><code>0x1000</code></td></tr>
<tr><td>CLINT</td><td><code>0x0200_0000</code></td><td><code>0x10000</code></td></tr>
<tr><td>PCIe PIO</td><td><code>0x0300_0000</code></td><td><code>0x10000</code></td></tr>
<tr><td>PLIC</td><td><code>0x0c00_0000</code></td><td><code>0x4000000</code></td></tr>
<tr><td>UART0</td><td><code>0x1000_0000</code></td><td><code>0x100</code></td></tr>
<tr><td>Virtio</td><td><code>0x1000_1000</code></td><td><code>0x1000</code></td></tr>
<tr><td>Flash</td><td><code>0x2000_0000</code></td><td><code>0x4000000</code></td></tr>
<tr><td>PCIe ECAM</td><td><code>0x3000_0000</code></td><td><code>0x10000000</code></td></tr>
<tr><td>PCIe MMIO</td><td><code>0x4000_0000</code></td><td><code>0x40000000</code></td></tr>
<tr><td>DRAM</td><td><code>0x8000_0000</code></td><td><code>{mem size}</code></td></tr>
</tbody></table>
</div>
<h3 id="getting-control-from-opensbi"><a class="header" href="#getting-control-from-opensbi">Getting control from OpenSBI</a></h3>
<p>On QEMU, we can get control from OpenSBI by linking a binary at <code>0x80200000</code>, and then using <code>-kernel</code> to
automatically load it at the right location. OpenSBI will then jump to this location with the HART ID in <code>a0</code> and
a pointer to the device tree in <code>a1</code>.</p>
<p>However, this does make setting paging up slightly icky, as has been a problem on other architectures. Basically,
the first binary needs to be linked at a low address with bare translation, and then we need to construct page
tables and enable translation, then jump to a higher address. I'm thinking we might as well do it in two stages:
a Seed stage that loads the kernel and early tasks from the filesystem/network/whatever, builds the kernel page
tables, and then enters the kernel and can be unloaded at a later date. The kernel can then be linked normally at
its high address without faffing around with a bootstrap or anything.</p>
<h3 id="the-device-tree"><a class="header" href="#the-device-tree">The device tree</a></h3>
<p>So the device tree seems to be a data structure passed to you that tells you about the hardware present / memory
etc. Hopefully it's less gross than ACPI eh. Repnop has written <a href="https://docs.rs/fdt/0.1.3/fdt/">a crate, <code>fdt</code></a>,
so I think we're just going to use that.</p>
<p>So <code>fdt</code> seems to work fine, we can list memory regions etc. The only issue seems to be that <code>memory_reservations</code>
doesn't return anything, which is kind of weird. There also seems to be a <code>/reserved-memory</code> node, but <a href="https://github.com/devicetree-org/devicetree-specification/blob/master/source/chapter3-devicenodes.rst#reserved-memory-and-uefi">this</a>
suggests that this doesn't include stuff we want like which part of memory OpenSBI resides in.</p>
<p><a href="https://github.com/riscv-software-src/opensbi/issues/70">This issue</a> says Linux just assumes it shouldn't touch
anything before it was loaded. I guess we could use the same approach, reserving the memory used by Seed via linker
symbols, and then seeing where the <code>loader</code> device gets put to reserve the ramdisk, but the issue was closed saying
OpenSBI now does the reservations correctly which would be cleaner, but doesn't stack up with what we're seeing.</p>
<p>Ah so actually, <code>/reserved-memory</code> does seem to have some of what we need. On QEMU there is one child node, called
<code>mmode_resv@80000000</code>, which would fit with being the memory OpenSBI is in. We would still need to handle the
memory we're in, and idk what happens with the <code>loader</code> device yet, but it's a start. Might be worth talking to
repnop about whether the crate should use this node.</p>
<h3 id="dumb-way-to-load-the-kernel-for-now"><a class="header" href="#dumb-way-to-load-the-kernel-for-now">Dumb way to load the kernel for now</a></h3>
<p>So for some reason, <code>fw_cfg</code> doesn't seem to be working on QEMU 7.1. This is what we were gonna use for loading the
kernel, command line, and user programs, etc. but obvs this is not possible atm. For now, as a workaround, we can
use the <code>loader</code> device to load arbitrary data and files into memory.</p>
<p>I'm thinking we could use <code>0x1_0000_0000</code> as the base physical address for this - this gives us a maximum of 2GiB
of DRAM, which seems plenty for now (famous last words). We'll need to know the size of the object we're loading on
the guest-side, so we'll load that separately for now (in the future, this whole scheme could be extended to some
sort of mini-filesystem).</p>
<p>Okay so the <code>loader</code> device is pretty finnicky, and has no error handling. Turns out you can't define new memory
with it, just load values into RAM, but it doesn't actually tell you this has failed. You then try and read this
on the guest, and get super wierd UB from doing so - it doesn't just fault or whatever, it seems to break code
before you ever read the memory (super weird ngl, didn't stick around to work out what was going on).</p>
<p>Right, seems to be working much better by actually putting the values in RAM. We've extended RAM to 1GiB
(<code>0x8000_0000..0xc000_0000</code>) and we'll use this as the new layout:</p>
<div class="table-wrapper"><table><thead><tr><th>Address</th><th>Description</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>0xb000_0000</td><td>Size of Data</td><td>4</td></tr>
<tr><td>0xb000_0004</td><td>Data</td><td>N</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
